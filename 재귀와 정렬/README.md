

# 정렬

![Untitled (1)](https://github.com/soberdam/ssafy-10th-algorithm-study/assets/106129404/05b83d1b-683d-47b3-ad5e-cf984c10476e)


- 컴퓨터 공학에서 중요시되는 문제 중 하나로, 어떤 데이터셋이 주어졌을 때 이를 정해진 순서대로 나열하여 재배치하는 문제

## stable vs unstable

![img](https://github.com/soberdam/ssafy-10th-algorithm-study/assets/106129404/1137c8b5-d7e6-4feb-990a-ca7e083971b4)


- 중복된 키값이 있을때 순서를 유지하면 stable, 순서가 바뀔 수 있으면 unstable 정렬

## in-place vs not in-place

- in-place 정렬은 원소들의 개수에 비해 충분히 무시할 만한 저장 공간만을 더 사용하는 정렬 알고리즘을 뜻한다.
- not in-place 정렬은 원소들의 개수에 비례하여 저장 공간을 더 사용하는 정렬 알고리즘을 뜻한다.

## 버블 정렬

![images_kerri_post_b5fa1d71-8712-4123-9446-5b3c0a9a5cdf_Bubble_sort](https://github.com/soberdam/ssafy-10th-algorithm-study/assets/106129404/54dbf5c8-ba99-4c6d-9ec7-0559f16698db)


- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 끝부터 정렬하는 방식
- 거의 모든 상황에서 최악의 성능을 보여주지만, 이미 정렬된 자료에서는 1번만 순회하면 되기 때문에 최선의 성능을 보여주는 알고리즘
- 한번 순회할 때마다 마지막 하나가 정렬되므로 원소들이 거품이 올라오는 것처럼 보여서 **`버블정렬`**이라고 부른다.
- 직관적이라서 구현하기 편하긴 하지만 꽤나 비효율적인 정렬 방식

## 선택정렬

![images_kerri_post_1322454c-1ba6-4ed1-9bf6-c999c4b58b8c_selection_sort](https://github.com/soberdam/ssafy-10th-algorithm-study/assets/106129404/36e50438-f0af-4b18-a986-5d58236e8780)


- 주어진 자료들 중에 최소값을 찾아 선택하여 위치를 교환하는 정렬 알고리즘
- 한번 순회를 돌게되면 알고리즘 상 전체 자료 중 가장 작은 값의 자료가 0번째 인덱스에 위치하게 되므로 그 다음 순회부터는 1번 인덱스부터 순회를 돌며 반복
- 반대로 최댓값을 찾아 뒤에서부터 교환해도 된다.
- 선택정렬은 현재 자료가 정렬이 되어있던말던 무조건 전체 리스트를 순회해가며 검사하기 때문에 최선의 경우든 최악의 경우든 한결같이O(n^2)의 시간복잡도를 가지고 있다

## 삽입정렬

![images_kerri_post_5d8fe005-d982-414d-a6dd-19dae0cbb60b_Insertion_sort](https://github.com/soberdam/ssafy-10th-algorithm-study/assets/106129404/d829c521-f904-47fc-9192-20fac5f85084)


- **`삽입정렬`**은 주어진 자료의 모든 요소를 앞에서부터 차례대로 정렬된 자료 부분과 비교하여 자신의 위치를 찾아 삽입하는 정렬
- 삽입정렬은 최선의 경우 전체 자료를 한번만 순회하면 되기때문에O(n)의 시간복잡도를 가지지만 최악의 경우O(n^2)의 시간복잡도를 가진다.

## 병합정렬

![images_kerri_post_e8a5533e-d255-4d10-adbc-b6335cdde2e3_Merge_sort](https://github.com/soberdam/ssafy-10th-algorithm-study/assets/106129404/d1eca255-1a10-49f2-95cb-da8507014f67)

 

- 작은 단위로 잘게 쪼개어 작은 단위부터 정렬해서 정렬된 단위들을 계속 병합해가는 정렬 방식
- **`분할 정복법`** 중 하나로 큰 문제를 작은 여러 개의 문제로 쪼개서 각각을 해결한 후 결과를 모아서 원래의 문제를 해결하는 방법이다. 병합이라는 이름 그대로 주어진 자료를 잘게 쪼갠 뒤 합치는 과정에서 정렬을 하는 알고리즘
- 같은 방식으로 계속 반복하여 병합하고 있기 때문에 병합정렬은 보통 재귀함수로 구현한다. 또한 병합정렬은 항상O(nlogn)의 시간복잡도를 가지기 때문에 효율적이다.
- 그러나 원소의 개수만큼 리스트를 쪼개고 따로 저장하고 있어야하기 때문에O(n)의 공간복잡도를 가진다. 한마디로 메모리를 팔아 수행속도를 얻는 경우라고 할 수 있다

## 퀵정렬

![images_kerri_post_578ce56e-121d-4eff-9fe3-50a20947aff2_Quick_sort](https://github.com/soberdam/ssafy-10th-algorithm-study/assets/106129404/a0378fe5-1dc6-408d-bcf6-b8a3c5d07eb3)


- 처음 하나의 축(Pivot)을 정하여 이 축의 값보다 작은 값은 왼쪽에 큰 값은 오른쪽으로 위치시킨뒤 왼쪽과 오른쪽의 수 들은 다시 각각의 축으로 나누어져 축값이 1이 될 때까지 정렬
- **`퀵정렬`**도 병합정렬과 마찬가지로 분할정복을 통한 정렬방법이다. 병합정렬과의 차이점은 병합정렬은 분할 단계에서는 아무것도 하지않고 병합하는 단계에서 정렬을 수행하지만, 퀵정렬은 분할 단계에서 중요한 작업들을 수행하고 병합시에는 아무것도 하지않는다는 점이다.
- 퀵정렬의 수행 순서는 다음과 같다.

---

1. 입력된 자료 리스트에서 하나의 원소를 고른다. 이 원소를 **`피벗`**이라고 부른다.
2. 피벗을 기준으로 리스트를 둘로 분할한다.
3. 피벗을 기준으로 피벗보다 작은 원소들은 모두 피벗의 왼쪽으로 옮긴다
4. 피벗을 기준으로 피벗보다 큰 원소들은 모두 피벗의 오른쪽으로 옮긴다

- 시간복잡도가 평균 O(nlogn)으로 준수하나, 피벗의 위치에 따라 최악의 경우 O(n^2)까지 걸릴 수 있다.



# 재귀

![Untitled (2)](https://github.com/soberdam/ssafy-10th-algorithm-study/assets/106129404/fbddd074-2097-4a2a-9560-e31d742c9ffd)


- 재귀함수란, 함수가 자기 자신을 함수 안에서 호출하여 작업을 수행하는 알고리즘이다.
- 절차지향적 사고가 아닌 귀납적 사고를 통해 문제에 접근해야한다.

## 귀납적 사고

- 절차지향적 사고 : 도미노가 1개쓰러지고, 2개쓰러지고 3개쓰러지고.. 하다보면 모든 n개가 쓰러짐
- 귀납적 사고 : 1번 도미노는 반드시 쓰러지며, k번 도미노가 쓰러지면 k+1번 도미노가 쓰러짐. 따라서 모든 도미노는 쓰러진다.

## 재귀함수의 특징

### 스택 메모리

![images_jewon119_post_76da41b6-983d-474b-b950-ee25cdf9f8c7_Et0ScQ8XEAYbXob](https://github.com/soberdam/ssafy-10th-algorithm-study/assets/106129404/b7fbd875-d515-4a28-806e-67cc76354b7b)


- 스택처럼 호출한 함수를 쌓았다가 종료조건을 만나면 위에서부터 하나씩 꺼내 처리하는 방식이다.

### 종료 조건

```java
void recursiveCall(int n) {
	if(n==0) return; // base condition
	
	recursiveCall(n-1);
}
```

- 함수가 종료되는 시점인 Base condition을 반드시 명시해야 무한루프에 빠지지 않는다.

### 반복문

- 모든 재귀함수는 반복문으로 표현할 수 있다.
- 반복문에 비해 코드가 간결해진다는 장점이 있지만, 메모리나 수행시간에서 손해를 본다.
- 반복문으로 구현해보고, 너무 복잡해지면 재귀를 통해 구현하는 것이 바람직하다.

## 재귀의 예시

- 팩토리얼
- 최대 공약수(유클리드 호제법)
- palindrome(회문 검사)
